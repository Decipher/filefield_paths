<?php
// $Id$

/**
 * @file
 * Adds extra functionality to FileFields Path settings.
 */

/**
 * Implementation of hook_form_alter().
 */
function filefield_paths_form_alter($form_id, &$form) {
  if (preg_match('/\bfilefield\b|\bimagefield\b/', $form['module']['#value'])) {
    $result = db_fetch_object(
      db_query("SELECT filename, filepath FROM {filefield_paths} WHERE type = '%s' AND field = '%s'",
      $form['type_name']['#value'], $form['field_name']['#value'])
    );

    if (!empty($result)) {
      $settings['file_path'] = unserialize($result->filepath);
      $settings['file_name'] = unserialize($result->filename);
    }

    $filepath = $form['module']['#value'] == 'filefield' ? 'file_path' : 'image_path';

    $form['widget'][$filepath]['#description'] = t('Optional subdirectory within the "%dir" directory where files will be stored. Do not include trailing slash.', array('%dir' => variable_get('file_directory_path', 'files')));
    if ($filepath == 'image_path') {
      unset($form['widget'][$filepath]['#suffix']);
    }

    $form['widget']['description']['#weight'] = 10;

    // Create path settings fieldset
    $form['widget']['path_settings'] = array(
      '#type' => 'fieldset',
      '#title' => 'Path settings',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE
    );

    // Move file path field into path settings fieldset
    $form['widget']['path_settings'][$filepath] = $form['widget'][$filepath];
    unset($form['widget'][$filepath]);

    // Create file name field
    $form['widget']['path_settings']['file_name'] = array(
      '#type' => 'textfield',
      '#title' => 'File name',
      '#default_value' => isset($settings['file_name']['value'])
        ? $settings['file_name']['value']
        : '[filefield_paths-name].[filefield_paths-ext]'
      ,
      '#weight' => 2
    );

    $fields = array(
      'file_path' => array(
        'title' => 'File path',
        'default' => $form['widget']['path_settings']['file_path']['#default_value'],
        'weight' => 0
      ),
      'file_name' => array(
        'title' => 'File name',
        'default' => '[filefield_paths-name].[filefield_paths-ext]',
        'weight' => 3
      )
    );

    foreach ($fields as $field => $data) {
      // Set defualt value for patterns
      $form['widget']['path_settings'][$field]['#default_value'] = isset($settings[$field]['value'])
        ? $settings[$field]['value']
        : $data['default'];

      // Replacement patterns for field
      $form['widget']['path_settings'][$field .'_tokens'] = array(
        '#type' => 'fieldset',
        '#title' => $data['title'] .' replacement patterns',
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#description' => $field == 'file_name'
          ? theme('token_help', 'field') . theme('token_help', 'node')
          : theme('token_help', 'node')
        ,
        '#weight' => $data['weight']
      );

      $form['widget']['path_settings'][$field .'_cleanup'] = array(
        '#type' => 'fieldset',
        '#title' => $data['title'] .' cleanup settings',
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#weight' => $data['weight'] + 1
      );

      // Cleanup field with Pathauto module
      $form['widget']['path_settings'][$field .'_cleanup'][$field .'_pathauto'] = array(
        '#type' => 'checkbox',
        '#title' => 'Cleanup using Pathauto.',
        '#default_value' => isset($settings[$field]['pathauto'])
          ? $settings[$field]['pathauto']
          : 0
        ,
        '#description' => 'Cleanup '. $data['title'] .' using '. l('Pathauto settings', 'admin/build/path/pathauto')
      );
      if (!module_exists('pathauto')) {
        $form['widget']['path_settings'][$field .'_cleanup'][$field .'_pathauto']['#disabled'] = TRUE;
        $form['widget']['path_settings'][$field .'_cleanup'][$field .'_pathauto']['#default_value'] = 0;
      }

      // Convert field to lower case
      $form['widget']['path_settings'][$field .'_cleanup'][$field .'_tolower'] = array(
        '#type' => 'checkbox',
        '#title' => 'Convert to lower case.',
        '#default_value' => isset($settings[$field]['tolower'])
          ? $settings[$field]['tolower']
          : 0
        ,
        '#description' => 'Convert '. $data['title'] .' to lower case.'
      );

      // Transliterate field with Transliteration module
      $form['widget']['path_settings'][$field .'_cleanup'][$field .'_transliterate'] = array(
        '#type' => 'checkbox',
        '#title' => 'Transliterate.',
        '#default_value' => isset($settings[$field]['transliterate'])
          ? $settings[$field]['transliterate']
          : 0
        ,
        '#description' => 'Transliterate '. $data['title'] .'.'
      );
      if (!module_exists('transliteration')) {
        $form['widget']['path_settings'][$field .'_cleanup'][$field .'_transliterate']['#disabled'] = TRUE;
        $form['widget']['path_settings'][$field .'_cleanup'][$field .'_transliterate']['#default_value'] = 0;
      }

    }

    $form['#submit']['filefield_paths_form_submit'] = array();
  }
}

/**
 * Implementation of hook_form_submit().
 */
function filefield_paths_form_submit($form, $form_values) {
  $settings['filename'] = array(
    'value' => $form_values['file_name'],
    'tolower' => $form_values['file_name_tolower'],
    'pathauto' => $form_values['file_name_pathauto'],
    'transliterate' => $form_values['file_name_transliterate']
  );

  $settings['filepath'] = array(
    'value' => $form_values['file_path'],
    'tolower' => $form_values['file_path_tolower'],
    'pathauto' => $form_values['file_path_pathauto'],
    'transliterate' => $form_values['file_path_transliterate']
  );

  $result = db_fetch_object(
    db_query("SELECT filename, filepath FROM {filefield_paths} WHERE type = '%s' AND field = '%s'",
    $form_values['type_name'], $form_values['field_name'])
  );

  if (!empty($result)) {
    db_query(
      "UPDATE {filefield_paths} SET filename = '%s', filepath = '%s' WHERE type = '%s' AND field = '%s'",
      serialize($settings['filename']), serialize($settings['filepath']),
      $form_values['type_name'], $form_values['field_name']
    );
  }

  else {
    db_query(
      "INSERT INTO {filefield_paths} (type, field, filename, filepath) VALUES ('%s', '%s', '%s', '%s')",
      $form_values['type_name'], $form_values['field_name'],
      serialize($settings['filename']), serialize($settings['filepath'])
    );
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function filefield_paths_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {

  switch ($op) {
    case 'submit':
      $content_type = content_types($node->type);

      foreach ($content_type['fields'] as $field) {
        if (preg_match('/\bfile\b|\bimage\b/', $field['type']) && is_array($node->$field['field_name'])) {

          foreach ($node->$field['field_name'] as $count => &$file) {
            if (empty($file['filepath'])) {
              continue;
            }

            // If file is newly uploaded, flag to be processed
            if ($file['fid'] == 'upload') {
              $file['data']['process'] = TRUE;
            }
          }

        }
      }
      break;

    case 'insert':
    case 'update':
      $content_type = content_types($node->type);
      $update = FALSE;

      foreach ($content_type['fields'] as $field) {
        if (preg_match('/\bfile\b|\bimage\b/', $field['type']) && is_array($node->$field['field_name'])) {

          $result = db_fetch_object(
            db_query("SELECT filename, filepath FROM {filefield_paths} WHERE type = '%s' AND field = '%s'", $node->type, $field['field_name'])
          );

          $settings['filepath'] = unserialize($result->filepath);
          $settings['filename'] = unserialize($result->filename);

          foreach ($node->$field['field_name'] as $count => &$file) {
            if (empty($file['filepath']) || empty($file['data']['process'])) {
              continue;
            }

            // Process filepath
            $file['old']['filepath'] = $file['filepath'];
            $file['new']['filepath'] = filefield_paths_process_string($file['filepath'], 'node', $node, $settings['filepath']);

            // Process filename
            $file['old']['filename'] = $file['filename'];
            if (($file['new']['filename'] = $settings['filename']['value']) != '') {
              $file['new']['filename'] = filefield_paths_process_string($file['new']['filename'], 'node', $node, $settings['filename']);
              $file['new']['filename'] = filefield_paths_process_string($file['new']['filename'], 'field', array(0 => $file), $settings['filename']);
            }
            else {
              $file['new']['filename'] = $file['filename'];
            }

            // Finalize files if necessary
            if ($file['new']['filepath'] != $file['filepath'] || $file['new']['filename'] != $file['filename']) {
              if (filefield_paths_file_move($file)) {

                // Fix reference to old paths in Body and Teaser
                // @TODO: allow for CCK fields
                $body = str_replace($file['old']['filepath'],  $file['new']['filepath'], $node->body);
                $teaser = str_replace($file['old']['filepath'],  $file['new']['filepath'], $node->teaser);

                if ($body != $node->body || $teaser != $node->teaser) {
                  $node->body = $body;
                  $node->teaser = $teaser;
  
                  $update = TRUE;
                }

                // Cleanup file array
                $file['filename'] = $file['new']['filename'];
                unset($file['new']);
                unset($file['old']);
              }
            }

          }

          // Cleanup temporary paths
          $paths = explode('/', $field['widget']['file_path']);

          while ($paths) {
            if (@rmdir(file_directory_path() .'/'. implode('/', $paths)) === TRUE) {
              array_pop($paths);
              continue;
            }
            break;
          }

        }
      }

      // Re-write node entry if required
      if ($update == TRUE) {
        $arr = array();
        foreach ($node_table_types as $key => $value) {
          $arr[] = $key .' = '. $value;
        }
        $node_table_values[] = $node->nid;
        $node_query = 'UPDATE {node} SET '. implode(', ', $arr) .' WHERE nid = %d';
        if ($node->revision) {
          $revisions_query = 'INSERT INTO {node_revisions} ('. implode(', ', array_keys($revisions_table_types)) .') VALUES ('. implode(', ', $revisions_table_types) .')';
        }
        else {
          $arr = array();
          foreach ($revisions_table_types as $key => $value) {
            $arr[] = $key .' = '. $value;
          }
          $revisions_table_values[] = $node->vid;
          $revisions_query = 'UPDATE {node_revisions} SET '. implode(', ', $arr) .' WHERE vid = %d';
        }

        db_query($node_query, $node_table_values);
        db_query($revisions_query, $revisions_table_values);
      }

      break;
  }
}

/**
 * Implementation of hook_token_list().
 */
function filefield_paths_token_list($type = 'all') {
  if ($type == 'field' || $type == 'all') {
    $tokens = array();
    $tokens['file']['filefield_paths-name'] = t("File name");
    $tokens['file']['filefield_paths-ext'] = t("File extension");
    return $tokens;
  }
}

/**
 * Implementation of hook_token_values().
 */
function filefield_paths_token_values($type, $object = NULL) {
  if ($type == 'field') {
    $item = pathinfo($object[0]['filename']);
    $tokens['filefield_paths-name'] = $item['filename'];
    $tokens['filefield_paths-ext'] = $item['extension'];
    return $tokens;
  }
}

/**
 * Process and cleanup strings.
 */
function filefield_paths_process_string($original, $type, $object, $settings) {

  // Process string tokens via Pathauto module
  if (module_exists('pathauto') && $settings['pathauto']) {
    $placeholders = pathauto_get_placeholders($type, $object);
    $value = str_replace($placeholders['tokens'], $placeholders['values'], $original);
  }

  // Process string tokens via Token module
  else {
    $value = token_replace($original, $type, $object);
  }

  // Transliterate string
  if (module_exists('transliteration') && $settings['transliterate']) {
    $value = transliteration_get($value);
    if ($type == 'field') {
      $value = transliteration_clean_filename($value);
    }
  }

  // Convert string to lower case
  if ($settings['tolower'] || ($settings['pathauto'] && variable_get('pathauto_case', 0))) {
    // Convert string to lower case
    $value = drupal_strtolower($value);
  }

  return $value;
}

/**
 * Move file and update its database record.
 */
function filefield_paths_file_move(&$file, $replace = FILE_EXISTS_RENAME) {
  $dest = dirname($file['new']['filepath']);

  $dirpath = file_directory_path();
  $dirlen = drupal_strlen($dirpath);
  if (drupal_substr($dest, 0, $dirlen + 1) == $dirpath .'/') {
    $dest = drupal_substr($dest, $dirlen + 1);
  }

  foreach (explode('/', $dest) as $dir) {
    $dirs[] = $dir;
    $path = file_create_path(implode($dirs, '/'));
    if (!filefield_check_directory($path, $form_item)) {
      watchdog('filefield_paths', t('FileField Paths failed to create directory (%d).', array('%d' => $path)), WATCHDOG_ERROR);
      return FALSE;
    }
  }

  if (!file_move($file['filepath'], $dest .'/'. $file['new']['filename'], $replace)) {
    watchdog('filefield_paths', t('FileField Paths failed to move file (%o) to (%n).', array('%o' => $file['old']['filepath'], '%n' => $dest .'/'. $file['new']['filename'])), WATCHDOG_ERROR);
    return FALSE;
  }

  db_query('UPDATE {files} SET filename = "%s", filepath = "%s" WHERE fid = %d', $file['new']['filename'], $file['filepath'], $file['fid']);

  return TRUE;
}
